# app/packs/ai/fund_formula_generator.rb

# The FundFormulaGenerator class is a service that leverages a Large Language Model (LLM)
# to generate a one-line Ruby formula based on a natural language description.
# It acts as the inverse of the FundFormulaExplainer, turning human intent into executable code.
class FundFormulaGenerator
  # Defines the maximum number of similar formulas to be used as examples in the prompt.
  # This is a form of "few-shot" prompting to improve the accuracy of the generated formula.
  EXAMPLE_FORMULAS_COUNT = 5

  # The main entry point for the generator. It constructs a detailed prompt and calls the LLM service.
  #
  # @param name [String] The name of the formula to be generated.
  # @param rule_type [String] The type of rule, which determines the available variables.
  # @param description [String] The user-provided description of the formula's logic.
  # @return [String] The raw, one-line Ruby formula generated by the AI.
  def self.call(name:, rule_type:, entry_type:, description:)
    # Use the centralized service to get all relevant variables.
    variables = FundFormulaVariableService.variables_for(rule_type.to_sym)
    # Fetch few-shot examples to guide the AI.
    examples = fetch_examples(name, rule_type, entry_type)

    # Construct the detailed prompt using the gathered information.
    prompt = build_prompt(name, rule_type, description, variables, examples)

    Rails.logger.error { "FundFormulaGenerator: prompt = #{prompt}" }
    # Call the LlmService to get the AI-generated formula.
    # The `.strip` method removes any leading/trailing whitespace from the response.
    LlmService.chat(
      prompt: prompt,
      provider: "gemini",
      llm_model: "gemini-2.5-flash-preview-05-20"
    ).strip
  end

  # private scope for helper methods
  class << self
    private

    # Fetches a formatted string of example formulas to include in the prompt.
    # @param name [String] The name of the formula to find similar examples for.
    # @param rule_type [String] The rule type to filter examples.
    # @param entry_type [String] The entry type to filter examples.
    # @return [String] A formatted string of examples.
    def fetch_examples(name, rule_type, entry_type)
      base_scope = FundFormula.where(name: name)
                              .where.not(formula: [nil, ""])
                              .where.not(ai_description: [nil, ""])

      prioritized = base_scope
                    .select("fund_formulas.*,
             CASE
               WHEN rule_type = #{ActiveRecord::Base.connection.quote(rule_type)} THEN 1
               WHEN entry_type = #{ActiveRecord::Base.connection.quote(entry_type)} THEN 2
               ELSE 3
             END AS priority")
                    .order("priority ASC")
                    .limit(EXAMPLE_FORMULAS_COUNT)

      prioritized.map do |formula|
        "AI Description: #{formula.ai_description}\n" \
          "User Description: #{formula.description}\n" \
          "Formula: #{formula.formula}"
      end.join("\n\n")
    end

    # Constructs the full prompt for the LLM.
    # @param name [String] The name for the new formula.
    # @param rule_type [String] The rule type for the new formula.
    # @param description [String] The user's description of the formula.
    # @param variables [Hash] A hash of available variables.
    # @param examples [String] A formatted string of example formulas.
    # @return [String] The complete prompt.
    def build_prompt(name, rule_type, description, variables, examples)
      <<~PROMPT
        You are an expert AI generating Ruby formulas for fund allocations.

        Given:
        - Formula name: #{name}
        - Rule Type: #{rule_type}
        - User Description: #{description}

        Prefer using the following variables:
        - Context: #{variables[:ctx].join(', ')}
        - Instance: #{variables[:instance].join(', ')}
        - Derived: #{variables[:derived].join(', ')}

        Examples of similar formulas:
        #{examples.presence || '- (none)'}

        Generate a one-line Ruby expression that matches the intent.

        Only return the Ruby formula. No explanation, no formatting.
      PROMPT
    end
  end
end
